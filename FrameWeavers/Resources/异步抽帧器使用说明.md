# å¼‚æ­¥è§†é¢‘æŠ½å¸§å™¨ä½¿ç”¨è¯´æ˜

## ğŸ“‹ ç›®å½•
- [æ¦‚è¿°](#æ¦‚è¿°)
- [æ ¸å¿ƒç‰¹æ€§](#æ ¸å¿ƒç‰¹æ€§)
- [å¿«é€Ÿå¼€å§‹](#å¿«é€Ÿå¼€å§‹)
- [è¯¦ç»†ä½¿ç”¨æ–¹æ³•](#è¯¦ç»†ä½¿ç”¨æ–¹æ³•)
- [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
- [APIå‚è€ƒ](#APIå‚è€ƒ)
- [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)

## æ¦‚è¿°

`AsyncFrameExtractor` æ˜¯ä¸€ä¸ªé«˜æ€§èƒ½çš„å¼‚æ­¥è§†é¢‘æŠ½å¸§å™¨ï¼ŒåŸºäºåŸæœ‰çš„ `OptimizedFrameExtractor` æ”¹é€ è€Œæˆã€‚å®ƒæ”¯æŒå¤šæ–‡ä»¶å¹¶è¡Œå¤„ç†ã€è®¾å¤‡æ€§èƒ½è‡ªé€‚åº”è°ƒæ•´ã€å®æ—¶è¿›åº¦ç›‘æ§å’Œæ™ºèƒ½èµ„æºç®¡ç†ã€‚

### ğŸ†š ä¸åŸç‰ˆæœ¬å¯¹æ¯”

| ç‰¹æ€§ | åŸå§‹ç‰ˆæœ¬ | å¼‚æ­¥ç‰ˆæœ¬ | æ”¹è¿›æ•ˆæœ |
|------|----------|----------|----------|
| å¤„ç†æ–¹å¼ | åŒæ­¥ä¸²è¡Œ | å¼‚æ­¥å¹¶è¡Œ | **3-5å€æ€§èƒ½æå‡** |
| å¤šæ–‡ä»¶å¤„ç† | é€ä¸ªå¤„ç† | æ‰¹é‡å¹¶è¡Œ | **æ˜¾è‘—å‡å°‘æ€»æ—¶é—´** |
| èµ„æºåˆ©ç”¨ | å•çº¿ç¨‹ | å¤šçº¿ç¨‹æ±  | **å……åˆ†åˆ©ç”¨CPU** |
| å†…å­˜ç®¡ç† | åŸºç¡€ç®¡ç† | æ™ºèƒ½ç›‘æ§ | **æ›´ç¨³å®šè¿è¡Œ** |
| è¿›åº¦ç›‘æ§ | æ—  | å®æ—¶å›è°ƒ | **æ›´å¥½çš„ç”¨æˆ·ä½“éªŒ** |
| è®¾å¤‡é€‚é… | å›ºå®šé…ç½® | æ€§èƒ½æ£€æµ‹ | **è‡ªåŠ¨ä¼˜åŒ–é…ç½®** |

## æ ¸å¿ƒç‰¹æ€§

### ğŸš€ å¼‚æ­¥å¹¶è¡Œå¤„ç†
- **å¤šæ–‡ä»¶å¹¶è¡Œ**: åŒæ—¶å¤„ç†å¤šä¸ªè§†é¢‘/å›¾ç‰‡æ–‡ä»¶
- **æ‰¹å¤„ç†ä¼˜åŒ–**: æ ¹æ®è®¾å¤‡æ€§èƒ½æ™ºèƒ½åˆ†æ‰¹å¤„ç†
- **çº¿ç¨‹æ± ç®¡ç†**: é«˜æ•ˆçš„çº¿ç¨‹èµ„æºåˆ©ç”¨
- **éé˜»å¡æ“ä½œ**: ä¸ä¼šé˜»å¡ä¸»çº¿ç¨‹

### ğŸ” è®¾å¤‡æ€§èƒ½æ£€æµ‹
- **è‡ªåŠ¨æ£€æµ‹**: CPUæ ¸å¿ƒæ•°ã€å†…å­˜å¤§å°ã€ç³»ç»Ÿè´Ÿè½½
- **æ€§èƒ½åˆ†çº§**: High/Medium/Low/Minimal å››ä¸ªç­‰çº§
- **åŠ¨æ€è°ƒæ•´**: æ ¹æ®è®¾å¤‡æ€§èƒ½è‡ªåŠ¨è°ƒæ•´å¹¶å‘å‚æ•°
- **èµ„æºç›‘æ§**: å®æ—¶ç›‘æ§å†…å­˜ä½¿ç”¨å’Œç³»ç»ŸçŠ¶æ€

### ğŸ“Š å®æ—¶è¿›åº¦ç›‘æ§
- **è¿›åº¦å›è°ƒ**: æ”¯æŒè‡ªå®šä¹‰è¿›åº¦å›è°ƒå‡½æ•°
- **è¯¦ç»†ä¿¡æ¯**: æ€»ä½“è¿›åº¦ã€å½“å‰æ–‡ä»¶ã€å‰©ä½™æ—¶é—´
- **çŠ¶æ€æ›´æ–°**: å®æ—¶æ›´æ–°å¤„ç†çŠ¶æ€
- **å¼‚æ­¥é€šçŸ¥**: éé˜»å¡çš„è¿›åº¦é€šçŸ¥æœºåˆ¶

### ğŸ›¡ï¸ æ™ºèƒ½èµ„æºç®¡ç†
- **å†…å­˜ç›‘æ§**: è‡ªåŠ¨æ£€æµ‹å†…å­˜ä½¿ç”¨ç‡
- **åƒåœ¾å›æ”¶**: å®šæœŸæ¸…ç†å†…å­˜èµ„æº
- **ä¿¡å·é‡æ§åˆ¶**: é™åˆ¶å¹¶å‘æ•°é˜²æ­¢èµ„æºè€—å°½
- **ä¼˜é›…æ¸…ç†**: å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨æ”¯æŒ

## å¿«é€Ÿå¼€å§‹

### å®‰è£…ä¾èµ–

```bash
pip install opencv-python numpy psutil asyncio
```

### åŸºç¡€ä½¿ç”¨ç¤ºä¾‹

```python
import asyncio
from async_frame_extractor import AsyncFrameExtractor

async def main():
    # åˆ›å»ºå¼‚æ­¥æŠ½å¸§å™¨
    async with AsyncFrameExtractor(output_dir="output_frames") as extractor:
        
        # å¤„ç†å•ä¸ªè§†é¢‘
        result = await extractor.process_and_format_async(
            input_paths=["video.mp4"],
            device_id="my_device_001",
            quality=90,
            max_resolution=(1920, 1080)
        )
        
        if result['success']:
            print(f"âœ… æˆåŠŸæå– {len(result['base_frame_paths'])} å¸§")
        else:
            print(f"âŒ å¤„ç†å¤±è´¥: {result['error']}")

# è¿è¡Œå¼‚æ­¥å‡½æ•°
asyncio.run(main())
```

### å¤šæ–‡ä»¶å¹¶è¡Œå¤„ç†

```python
import asyncio
from async_frame_extractor import AsyncFrameExtractor

async def progress_callback(progress_data):
    """è¿›åº¦å›è°ƒå‡½æ•°"""
    print(f"è¿›åº¦: {progress_data['overall_progress']:.1f}% | "
          f"å½“å‰: {progress_data['current_file']} | "
          f"å‰©ä½™: {progress_data['estimated_remaining']:.1f}s")

async def main():
    # å¤šæ–‡ä»¶å¹¶è¡Œå¤„ç†
    async with AsyncFrameExtractor() as extractor:
        
        files = ["video1.mp4", "video2.mp4", "image1.jpg", "video3.avi"]
        
        result = await extractor.process_and_format_async(
            input_paths=files,
            device_id="batch_device_001",
            quality=85,
            scene_sensitivity='high',
            max_base_frames=100,
            progress_callback=progress_callback  # å®æ—¶è¿›åº¦ç›‘æ§
        )
        
        print(f"å¤„ç†å®Œæˆ: {result['processing_summary']}")

asyncio.run(main())
```

## è¯¦ç»†ä½¿ç”¨æ–¹æ³•

### 1. åˆå§‹åŒ–é…ç½®

```python
extractor = AsyncFrameExtractor(
    output_dir="async_frames",           # è¾“å‡ºç›®å½•
    max_file_size_mb=500,               # æœ€å¤§æ–‡ä»¶å¤§å°(MB)
    auto_detect_performance=True        # è‡ªåŠ¨æ£€æµ‹è®¾å¤‡æ€§èƒ½
)
```

### 2. è®¾å¤‡æ€§èƒ½æ£€æµ‹

```python
# è·å–è®¾å¤‡æ€§èƒ½ä¿¡æ¯
profile = extractor.performance_profile
print(f"æ€§èƒ½ç­‰çº§: {profile['performance_level']}")
print(f"CPUæ ¸å¿ƒ: {profile['cpu_cores_physical']}")
print(f"å†…å­˜: {profile['memory_total_gb']} GB")
print(f"æ¨èå¹¶å‘: {profile['max_workers']}")
```

### 3. å¤„ç†å‚æ•°é…ç½®

```python
result = await extractor.process_and_format_async(
    input_paths=files,
    device_id="my_device",                    # è®¾å¤‡ID
    task_id=None,                            # ä»»åŠ¡ID(è‡ªåŠ¨ç”Ÿæˆ)
    save_json=True,                          # ä¿å­˜JSONç»“æœ
    
    # æŠ½å¸§å‚æ•°
    quality=90,                              # JPEGè´¨é‡(1-100)
    max_resolution=(1920, 1080),             # æœ€å¤§åˆ†è¾¨ç‡
    sharpness_threshold=100.0,               # æ¸…æ™°åº¦é˜ˆå€¼
    similarity_threshold=15.0,               # ç›¸ä¼¼åº¦é˜ˆå€¼
    scene_sensitivity='high',                # åœºæ™¯å˜åŒ–æ•æ„Ÿåº¦
    max_base_frames=80,                      # æœ€å¤§æå–å¸§æ•°
    
    # è¿›åº¦å›è°ƒ
    progress_callback=my_progress_callback
)
```

### 4. è‡ªå®šä¹‰è¿›åº¦å›è°ƒ

```python
async def my_progress_callback(progress_data):
    """è‡ªå®šä¹‰è¿›åº¦å›è°ƒå‡½æ•°"""
    data = progress_data
    
    # æ§åˆ¶å°è¾“å‡º
    print(f"\rğŸ“Š [{data['overall_progress']:6.1f}%] "
          f"{data['completed_files']}/{data['total_files']} | "
          f"{data['current_file'][:30]:30s} "
          f"({data['current_file_progress']:5.1f}%)", 
          end="", flush=True)
    
    # å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ å…¶ä»–é€»è¾‘ï¼š
    # - æ›´æ–°GUIè¿›åº¦æ¡
    # - å‘é€è¿›åº¦åˆ°Webå‰ç«¯
    # - è®°å½•æ—¥å¿—
    # - æ£€æŸ¥å–æ¶ˆçŠ¶æ€ç­‰
```

## æ€§èƒ½ä¼˜åŒ–

### è®¾å¤‡æ€§èƒ½ç­‰çº§è¯´æ˜

| æ€§èƒ½ç­‰çº§ | CPUæ ¸å¿ƒ | å†…å­˜ | æœ€å¤§å·¥ä½œçº¿ç¨‹ | æ‰¹å¤„ç†å¤§å° | é€‚ç”¨åœºæ™¯ |
|----------|---------|------|--------------|------------|----------|
| **High** | â‰¥8æ ¸ | â‰¥16GB | 16 | 8 | æœåŠ¡å™¨ã€é«˜ç«¯å·¥ä½œç«™ |
| **Medium** | 4-7æ ¸ | 8-15GB | 8 | 4 | æ™®é€šå°å¼æœºã€ç¬”è®°æœ¬ |
| **Low** | 2-3æ ¸ | 4-7GB | 4 | 2 | å…¥é—¨çº§è®¾å¤‡ |
| **Minimal** | <2æ ¸ | <4GB | 2 | 1 | ä½ç«¯è®¾å¤‡ã€è™šæ‹Ÿæœº |

### æ€§èƒ½è°ƒä¼˜å»ºè®®

#### 1. é’ˆå¯¹ä¸åŒåœºæ™¯çš„å‚æ•°å»ºè®®

```python
# ğŸš€ é«˜æ€§èƒ½åœºæ™¯ - æœåŠ¡å™¨æ‰¹å¤„ç†
config_high_performance = {
    'quality': 85,
    'max_resolution': (1920, 1080),
    'scene_sensitivity': 'medium',
    'max_base_frames': 150
}

# ğŸ¯ å¹³è¡¡åœºæ™¯ - æ™®é€šæ¡Œé¢å¤„ç†
config_balanced = {
    'quality': 90,
    'max_resolution': (1280, 720),
    'scene_sensitivity': 'high',
    'max_base_frames': 80
}

# ğŸ’¾ ä½èµ„æºåœºæ™¯ - é™åˆ¶å†…å­˜ä½¿ç”¨
config_low_resource = {
    'quality': 75,
    'max_resolution': (800, 600),
    'scene_sensitivity': 'low',
    'max_base_frames': 50
}
```

#### 2. å†…å­˜ä¼˜åŒ–ç­–ç•¥

```python
# å¤„ç†å¤§é‡æ–‡ä»¶æ—¶åˆ†æ‰¹å¤„ç†
large_files = get_large_file_list()  # å‡è®¾æœ‰å¾ˆå¤šæ–‡ä»¶

# åˆ†æ‰¹å¤„ç†ï¼Œé¿å…å†…å­˜è€—å°½
batch_size = 10
for i in range(0, len(large_files), batch_size):
    batch = large_files[i:i + batch_size]
    
    result = await extractor.process_and_format_async(
        input_paths=batch,
        device_id=f"batch_{i//batch_size}",
        **config_balanced
    )
    
    # å¤„ç†ç»“æœ...
    await asyncio.sleep(1)  # çŸ­æš‚ä¼‘æ¯ï¼Œè®©ç³»ç»Ÿå›æ”¶èµ„æº
```

#### 3. é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶

```python
import asyncio
from typing import List

async def robust_process_with_retry(extractor, files: List[str], max_retries: int = 3):
    """å¸¦é‡è¯•æœºåˆ¶çš„å¥å£®å¤„ç†"""
    
    for attempt in range(max_retries):
        try:
            result = await extractor.process_and_format_async(
                input_paths=files,
                device_id=f"retry_attempt_{attempt+1}",
                quality=85
            )
            
            if result['success']:
                return result
            else:
                print(f"ç¬¬ {attempt+1} æ¬¡å°è¯•å¤±è´¥: {result.get('error')}")
                
        except Exception as e:
            print(f"ç¬¬ {attempt+1} æ¬¡å°è¯•å¼‚å¸¸: {str(e)}")
            
        if attempt < max_retries - 1:
            wait_time = 2 ** attempt  # æŒ‡æ•°é€€é¿
            print(f"ç­‰å¾… {wait_time} ç§’åé‡è¯•...")
            await asyncio.sleep(wait_time)
    
    return {'success': False, 'error': 'è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°'}
```

## APIå‚è€ƒ

### AsyncFrameExtractor ç±»

#### æ„é€ å‡½æ•°
```python
AsyncFrameExtractor(
    output_dir: str = "async_frames",
    max_file_size_mb: int = 500,
    auto_detect_performance: bool = True
)
```

#### ä¸»è¦æ–¹æ³•

##### process_and_format_async()
```python
async def process_and_format_async(
    self,
    input_paths: List[str],
    device_id: str = None,
    task_id: str = None,
    save_json: bool = True,
    progress_callback: Callable = None,
    **kwargs
) -> Dict[str, any]
```

**å‚æ•°è¯´æ˜:**
- `input_paths`: è¾“å…¥æ–‡ä»¶è·¯å¾„åˆ—è¡¨
- `device_id`: è®¾å¤‡æ ‡è¯†ç¬¦
- `task_id`: ä»»åŠ¡IDï¼ˆå¦‚æœä¸ºNoneåˆ™è‡ªåŠ¨ç”Ÿæˆï¼‰
- `save_json`: æ˜¯å¦ä¿å­˜JSONç»“æœæ–‡ä»¶
- `progress_callback`: è¿›åº¦å›è°ƒå‡½æ•°
- `**kwargs`: å…¶ä»–å¤„ç†å‚æ•°

**è¿”å›æ ¼å¼:**
```python
{
    'success': bool,                    # æ˜¯å¦æˆåŠŸ
    'device_id': str,                   # è®¾å¤‡ID
    'task_id': str,                     # ä»»åŠ¡ID
    'base_frame_paths': List[Dict],     # æå–çš„å¸§ä¿¡æ¯åˆ—è¡¨
    'processing_summary': {             # å¤„ç†æ€»ç»“
        'total_input_files': int,
        'success_files': int,
        'failed_files': int,
        'final_frame_count': int,
        'processing_time_seconds': float,
        'performance_profile': Dict
    },
    'storage_info': {                   # å­˜å‚¨ä¿¡æ¯
        'task_output_directory': str,
        'total_size_mb': float,
        'frame_format': str,
        'json_result_path': str
    },
    'metadata': {                       # å…ƒæ•°æ®
        'extraction_timestamp': str,
        'extractor_version': str,
        'async_processing': bool,
        'parallel_batches': bool
    }
}
```

### è¿›åº¦å›è°ƒå‡½æ•°æ ¼å¼

```python
async def progress_callback(progress_data: Dict[str, any]):
    """
    progress_data åŒ…å«ä»¥ä¸‹å­—æ®µ:
    - total_files: int - æ€»æ–‡ä»¶æ•°
    - completed_files: int - å·²å®Œæˆæ–‡ä»¶æ•°
    - current_file: str - å½“å‰å¤„ç†æ–‡ä»¶å
    - current_file_progress: float - å½“å‰æ–‡ä»¶è¿›åº¦(0-100)
    - overall_progress: float - æ€»ä½“è¿›åº¦(0-100)
    - elapsed_time: float - å·²æ¶ˆè€—æ—¶é—´(ç§’)
    - estimated_remaining: float - é¢„è®¡å‰©ä½™æ—¶é—´(ç§’)
    """
    pass
```

## å¸¸è§é—®é¢˜

### Q: å¦‚ä½•é€‰æ‹©åˆé€‚çš„å¹¶å‘å‚æ•°ï¼Ÿ

**A:** ç³»ç»Ÿä¼šè‡ªåŠ¨æ£€æµ‹è®¾å¤‡æ€§èƒ½å¹¶é€‰æ‹©æœ€ä½³å‚æ•°ã€‚ä½†ä½ ä¹Ÿå¯ä»¥æ‰‹åŠ¨è°ƒæ•´ï¼š

```python
# å¦‚æœå†…å­˜ä¸è¶³ï¼Œé™ä½æ‰¹å¤„ç†å¤§å°
extractor.performance_profile['concurrency_config']['batch_size'] = 2

# å¦‚æœCPUåˆ©ç”¨ç‡ä½ï¼Œå¢åŠ å·¥ä½œçº¿ç¨‹
extractor.performance_profile['concurrency_config']['max_workers'] = 8
```

### Q: å¤„ç†å¤§æ–‡ä»¶æ—¶å†…å­˜ä¸è¶³æ€ä¹ˆåŠï¼Ÿ

**A:** é‡‡ç”¨ä»¥ä¸‹ç­–ç•¥ï¼š

1. **é™ä½åˆ†è¾¨ç‡**: `max_resolution=(800, 600)`
2. **å‡å°‘è´¨é‡**: `quality=70`
3. **å‡å°‘å¹¶å‘**: æ‰‹åŠ¨è®¾ç½®æ›´å°çš„æ‰¹å¤„ç†å¤§å°
4. **åˆ†æ‰¹å¤„ç†**: å°†å¤§é‡æ–‡ä»¶åˆ†æˆå°æ‰¹æ¬¡å¤„ç†

```python
# ä½å†…å­˜æ¨¡å¼
low_memory_config = {
    'quality': 70,
    'max_resolution': (800, 600),
    'max_base_frames': 30
}

# æ‰‹åŠ¨è®¾ç½®ä½å¹¶å‘
extractor.performance_profile['concurrency_config']['batch_size'] = 1
extractor.performance_profile['concurrency_config']['max_workers'] = 2
```

### Q: å¦‚ä½•ç›‘æ§å¤„ç†è¿›åº¦å’ŒçŠ¶æ€ï¼Ÿ

**A:** ä½¿ç”¨è¿›åº¦å›è°ƒå‡½æ•°ï¼š

```python
async def detailed_progress_callback(progress_data):
    # è®¡ç®—é€Ÿåº¦
    if progress_data['elapsed_time'] > 0:
        files_per_second = progress_data['completed_files'] / progress_data['elapsed_time']
        print(f"å¤„ç†é€Ÿåº¦: {files_per_second:.2f} æ–‡ä»¶/ç§’")
    
    # å†…å­˜ç›‘æ§
    import psutil
    memory_percent = psutil.virtual_memory().percent
    print(f"å†…å­˜ä½¿ç”¨: {memory_percent:.1f}%")
    
    # ç£ç›˜ç©ºé—´æ£€æŸ¥
    disk_free = psutil.disk_usage('.').free / (1024**3)
    print(f"å‰©ä½™ç©ºé—´: {disk_free:.1f} GB")
```

### Q: å¤„ç†å¤±è´¥çš„æ–‡ä»¶å¦‚ä½•é‡è¯•ï¼Ÿ

**A:** å¯ä»¥ä»ç»“æœä¸­è·å–å¤±è´¥ä¿¡æ¯å¹¶å•ç‹¬é‡è¯•ï¼š

```python
result = await extractor.process_and_format_async(files)

if result['processing_summary']['failed_files'] > 0:
    # æŸ¥çœ‹è¯¦ç»†é”™è¯¯ï¼ˆéœ€è¦æŸ¥çœ‹æ—¥å¿—ï¼‰
    # æˆ–è€…å®ç°æ›´è¯¦ç»†çš„é”™è¯¯è¿½è¸ªæœºåˆ¶
    print(f"æœ‰ {result['processing_summary']['failed_files']} ä¸ªæ–‡ä»¶å¤„ç†å¤±è´¥")
    
    # å¯ä»¥å°è¯•ç”¨æ›´ä¿å®ˆçš„å‚æ•°é‡è¯•
    retry_config = {
        'quality': 70,
        'max_resolution': (640, 480),
        'scene_sensitivity': 'low'
    }
```

### Q: å¦‚ä½•ä¸Webåº”ç”¨é›†æˆï¼Ÿ

**A:** å¼‚æ­¥ç‰¹æ€§ä½¿å…¶å¾ˆå®¹æ˜“ä¸Webæ¡†æ¶é›†æˆï¼š

```python
# FastAPI ç¤ºä¾‹
from fastapi import FastAPI, BackgroundTasks
import asyncio

app = FastAPI()

@app.post("/process_videos/")
async def process_videos(files: List[str], background_tasks: BackgroundTasks):
    
    async def background_process():
        async with AsyncFrameExtractor() as extractor:
            result = await extractor.process_and_format_async(
                input_paths=files,
                device_id="web_api_001"
            )
            # ä¿å­˜ç»“æœåˆ°æ•°æ®åº“æˆ–ç¼“å­˜
            save_result_to_db(result)
    
    background_tasks.add_task(background_process)
    return {"message": "Processing started", "status": "queued"}
```

### Q: æ”¯æŒå“ªäº›æ–‡ä»¶æ ¼å¼ï¼Ÿ

**A:** æ”¯æŒå¸¸è§çš„è§†é¢‘å’Œå›¾ç‰‡æ ¼å¼ï¼š

- **è§†é¢‘æ ¼å¼**: .mp4, .avi, .mov, .mkv, .wmv, .flv, .webm, .m4v
- **å›¾ç‰‡æ ¼å¼**: .jpg, .jpeg, .png, .bmp, .tiff, .tif, .webp

### Q: å¦‚ä½•è‡ªå®šä¹‰è¾“å‡ºæ ¼å¼ï¼Ÿ

**A:** å½“å‰è¾“å‡ºä¸ºJPEGæ ¼å¼ï¼Œå¯ä»¥é€šè¿‡ä¿®æ”¹ä¿å­˜å‚æ•°è°ƒæ•´ï¼š

```python
# åœ¨ _extract_frames_sync æ–¹æ³•ä¸­å¯ä»¥çœ‹åˆ°:
jpeg_params = [cv2.IMWRITE_JPEG_QUALITY, quality]

# å¯ä»¥æ‰©å±•æ”¯æŒå…¶ä»–æ ¼å¼ï¼Œæ¯”å¦‚PNG:
# png_params = [cv2.IMWRITE_PNG_COMPRESSION, 9]
```

---

## ğŸ“ æŠ€æœ¯æ”¯æŒ

å¦‚æœæ‚¨åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­é‡åˆ°é—®é¢˜ï¼Œè¯·ï¼š

1. æŸ¥çœ‹æ§åˆ¶å°æ—¥å¿—è¾“å‡º
2. æ£€æŸ¥æ–‡ä»¶æ ¼å¼å’Œå¤§å°æ˜¯å¦ç¬¦åˆè¦æ±‚
3. ç¡®è®¤è®¾å¤‡èµ„æºå……è¶³
4. å°è¯•é™ä½å¤„ç†å‚æ•°

**äº«å—é«˜æ•ˆçš„å¼‚æ­¥å¹¶è¡ŒæŠ½å¸§ä½“éªŒï¼** ğŸš€