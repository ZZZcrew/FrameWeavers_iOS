---
description: iOS17+ 现代响应式设计规范 - 基于最新SwiftUI特性的简洁高效布局方案
alwaysApply: true
---
# 📱 iOS17+ 现代响应式设计规范

**目标系统**: iOS17+, iPadOS17+ (不考虑更低版本)
**核心理念**: 简洁、现代、高效 - 充分利用最新SwiftUI特性

## 🎯 核心原则

### 1. 优先使用现代SwiftUI特性
- **Size Classes** - 替代复杂的设备检测
- **ScrollView** - 替代复杂的GeometryReader布局
- **Environment Values** - 响应系统设置变化
- **Dynamic Type** - 系统级字体缩放支持

### 2. 禁止过度工程化
- ❌ **禁止**自定义设备适配工具类
- ❌ **禁止**复杂的GeometryReader嵌套
- ❌ **禁止**手动计算屏幕尺寸
- ❌ **禁止**固定像素值布局
- ❌ **禁止**错误使用ViewThatFits (详见横屏适配章节)

## 🏗️ 现代布局架构

### 基础响应式模板
```swift
struct ModernResponsiveView: View {
    // MARK: - Environment
    @Environment(\.horizontalSizeClass) private var horizontalSizeClass
    @Environment(\.verticalSizeClass) private var verticalSizeClass

    var body: some View {
        ScrollView {
            VStack(spacing: adaptiveSpacing) {
                Spacer(minLength: topSpacing)

                // 内容组件
                contentView

                Spacer(minLength: bottomSpacing)
            }
            .padding(.horizontal, horizontalPadding)
            .frame(maxWidth: .infinity)
        }
    }
}

// MARK: - Adaptive Properties
private extension ModernResponsiveView {
    var isCompact: Bool {
        horizontalSizeClass == .compact || verticalSizeClass == .compact
    }

    var adaptiveSpacing: CGFloat { isCompact ? 16 : 24 }
    var topSpacing: CGFloat { isCompact ? 20 : 40 }
    var bottomSpacing: CGFloat { isCompact ? 20 : 40 }
    var horizontalPadding: CGFloat { isCompact ? 20 : 40 }
}
```

## 🔤 现代字体系统

### 系统字体样式 (iOS17+)
```swift
// ✅ 推荐：使用系统字体样式
Text("标题").font(.largeTitle)     // 34pt - 页面大标题
Text("标题").font(.title)         // 28pt - 页面标题
Text("标题").font(.title2)        // 22pt - 次要标题
Text("内容").font(.body)          // 17pt - 正文内容
Text("说明").font(.callout)       // 16pt - 说明文字
Text("脚注").font(.footnote)      // 13pt - 脚注
Text("标签").font(.caption)       // 12pt - 图片说明

// ❌ 禁止：固定字体大小
Text("标题").font(.system(size: 28)) // 禁止使用
```

### 动态类型支持
```swift
// ✅ 限制字体大小范围
Text("内容")
    .font(.body)
    .dynamicTypeSize(...DynamicTypeSize.accessibility1) // 限制最大字体

// ✅ 响应动态类型变化
@Environment(\.dynamicTypeSize) var dynamicTypeSize

var adaptiveFont: Font {
    dynamicTypeSize.isAccessibilitySize ? .title3 : .body
}
```

### 自定义字体的现代用法
```swift
// ✅ 支持动态类型的自定义字体
Text("内容")
    .font(.custom("STKaiti", size: 18))
    .dynamicTypeSize(...DynamicTypeSize.large) // 限制范围
```

## 📐 Size Classes 响应式设计

### 基础Size Classes判断
```swift
@Environment(\.horizontalSizeClass) private var horizontalSizeClass
@Environment(\.verticalSizeClass) private var verticalSizeClass

// 简洁的响应式判断
var isCompact: Bool {
    horizontalSizeClass == .compact
}

// 基于Size Classes的布局
var body: some View {
    if horizontalSizeClass == .compact {
        compactLayout    // iPhone竖屏、iPad分屏
    } else {
        regularLayout    // iPad横屏、iPhone横屏
    }
}
```

### 设备适配策略
- **iPhone**: 主要使用 `.compact` 水平尺寸类
- **iPad**: 主要使用 `.regular` 水平尺寸类
- **分屏/多窗口**: 自动适配为 `.compact`
- **横竖屏**: 通过 `verticalSizeClass` 判断

## 🔄 横屏适配最佳实践

### 横屏检测的正确方法
```swift
// ✅ 正确：基于Size Classes的横屏检测
var isLandscape: Bool {
    horizontalSizeClass == .compact && verticalSizeClass == .compact
}

// ❌ 错误：单独使用verticalSizeClass
var isLandscape: Bool {
    verticalSizeClass == .compact  // 不可靠
}
```

### 横屏布局策略
```swift
// ✅ 推荐：双布局系统
var body: some View {
    if horizontalSizeClass == .compact && verticalSizeClass == .compact {
        // iPhone横屏：使用HStack水平布局
        landscapeLayout
    } else {
        // 竖屏或iPad：使用VStack垂直布局
        portraitLayout
    }
}

// 横屏布局：去除ScrollView，直接使用HStack
var landscapeLayout: some View {
    HStack(spacing: compactSpacing) {
        VStack { /* 左侧内容 */ }
        VStack { /* 右侧内容 */ }
    }
    .padding(.horizontal, compactPadding)
    .frame(maxWidth: .infinity, maxHeight: .infinity)
}

// 竖屏布局：根据内容决定是否使用ScrollView
var portraitLayout: some View {
    // 如果内容适合屏幕，可以不使用ScrollView
    VStack(spacing: regularSpacing) {
        Spacer(minLength: topSpacing)
        // 垂直排列的内容
        Spacer(minLength: bottomSpacing)
    }
    .padding(.horizontal, regularPadding)
    .frame(maxWidth: .infinity, maxHeight: .infinity)

    // 或者使用ScrollView（内容较多时）
    // ScrollView {
    //     VStack(spacing: regularSpacing) {
    //         // 垂直排列的内容
    //     }
    //     .padding(.horizontal, regularPadding)
    // }
}
```

### ViewThatFits使用注意事项
```swift
// ❌ 错误：ViewThatFits不适合横屏适配
ViewThatFits(in: .vertical) {
    portraitLayout
    landscapeLayout
}

// ✅ 正确：ViewThatFits适合内容自适应
ViewThatFits {
    // 优先显示完整内容
    HStack { icon; title; description; button }

    // 空间不足时简化
    VStack { icon; title; button }

    // 最小布局
    VStack { title; button }
}
```

### 横屏适配原则
1. **移除ScrollView**：横屏时通常不需要滚动，直接使用HStack
2. **使用HStack**：水平排列主要内容
3. **适当调整尺寸**：横屏组件可以比竖屏稍大，充分利用水平空间
4. **固定高度**：使用`.frame(maxHeight: .infinity)`填满屏幕
5. **简化内容**：必要时隐藏次要元素
6. **竖屏也可无ScrollView**：如果内容适合屏幕，竖屏也可移除ScrollView

## 🎨 现代布局组件

### 布局选择策略
```swift
// ✅ 内容适合屏幕时：直接使用VStack (推荐)
VStack(spacing: adaptiveSpacing) {
    Spacer(minLength: topSpacing)

    // 内容组件
    welcomeIcon
    welcomeText
    actionButton
    hintText

    Spacer(minLength: bottomSpacing)
}
.padding(.horizontal, horizontalPadding)
.frame(maxWidth: .infinity, maxHeight: .infinity)

// ✅ 内容较多时：使用ScrollView + VStack
ScrollView {
    VStack(spacing: adaptiveSpacing) {
        // 内容组件
        welcomeIcon
        welcomeText
        actionButton
        hintText
    }
    .padding(.horizontal, horizontalPadding)
    .frame(maxWidth: .infinity)
}

// ❌ 旧模式 - 复杂且性能差
GeometryReader { geometry in
    VStack(spacing: 0) {
        DeviceAdaptation.responsiveSpacer(...)  // 禁止
        // 复杂的计算逻辑
    }
}
```

### ViewThatFits 自适应布局 (iOS16+)
```swift
// ✅ 自动选择合适的布局
ViewThatFits {
    // 优先显示完整布局
    HStack(spacing: 20) {
        image
        VStack { title; description }
        actionButton
    }

    // 空间不足时的简化布局
    VStack(spacing: 12) {
        image
        title
        actionButton
    }

    // 最小布局
    VStack(spacing: 8) {
        title
        actionButton
    }
}
```

### 响应式间距和尺寸
```swift
// ✅ 基于Size Classes的响应式属性
private extension View {
    var isCompact: Bool { horizontalSizeClass == .compact }
    var isLandscape: Bool {
        horizontalSizeClass == .compact && verticalSizeClass == .compact
    }

    // 竖屏属性
    var portraitSpacing: CGFloat { isCompact ? 16 : 24 }
    var portraitPadding: CGFloat { isCompact ? 20 : 40 }
    var portraitIconSize: CGFloat { isCompact ? 70 : 90 }

    // 横屏属性 (可以比竖屏稍大)
    var landscapeSpacing: CGFloat { 30 }
    var landscapePadding: CGFloat { 25 }
    var landscapeIconSize: CGFloat { 80 }  // 比竖屏compact(70)大
}

// ✅ 使用系统间距
VStack(spacing: .systemSpacing) { ... }  // iOS17+
HStack(spacing: .systemSpacing) { ... }

// 详细的属性定义请参考"双布局系统最佳实践"章节
```

## 🔀 双布局系统最佳实践

### 完整的双布局实现
```swift
struct AdaptiveView: View {
    @Environment(\.horizontalSizeClass) private var horizontalSizeClass
    @Environment(\.verticalSizeClass) private var verticalSizeClass

    var body: some View {
        ZStack {
            backgroundImage

            if horizontalSizeClass == .compact && verticalSizeClass == .compact {
                landscapeLayout  // iPhone横屏
            } else {
                portraitLayout   // 竖屏或iPad
            }
        }
    }
}

// MARK: - Layout Components
private extension AdaptiveView {
    var portraitLayout: some View {
        VStack(spacing: portraitSpacing) {
            Spacer(minLength: portraitTopSpacing)
            portraitTitleText
            Spacer(minLength: portraitMiddleSpacing)
            portraitMainContent
            Spacer(minLength: portraitBottomSpacing)
            portraitActionButton
            Spacer(minLength: portraitEndSpacing)
        }
        .padding(.horizontal, portraitPadding)
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }

    var landscapeLayout: some View {
        HStack(spacing: landscapeSpacing) {
            VStack(spacing: 15) {
                landscapeTitleText
                landscapeMainContent
            }
            .frame(maxWidth: .infinity)

            VStack {
                Spacer()
                landscapeActionButton
                Spacer()
            }
            .frame(width: landscapeButtonAreaWidth)
        }
        .padding(.horizontal, landscapePadding)
        .padding(.vertical, 10)
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
}

// MARK: - Adaptive Properties
private extension AdaptiveView {
    var isCompact: Bool { horizontalSizeClass == .compact }

    // 竖屏属性
    var portraitSpacing: CGFloat { isCompact ? 16 : 24 }
    var portraitTopSpacing: CGFloat { isCompact ? 20 : 40 }
    var portraitMiddleSpacing: CGFloat { isCompact ? 30 : 50 }
    var portraitBottomSpacing: CGFloat { isCompact ? 40 : 60 }
    var portraitEndSpacing: CGFloat { isCompact ? 20 : 40 }
    var portraitPadding: CGFloat { isCompact ? 20 : 40 }
    var portraitContentSize: CGFloat { isCompact ? 280 : 350 }

    // 横屏属性
    var landscapeSpacing: CGFloat { 30 }
    var landscapePadding: CGFloat { 25 }
    var landscapeContentSize: CGFloat { 240 }  // 比竖屏compact稍大
    var landscapeButtonAreaWidth: CGFloat { 220 }
}
```

## 🧪 测试检查清单

### 必测项目
- [ ] iPhone 15 Pro (标准竖屏)
- [ ] iPhone 15 Pro (横屏) - 重点测试
- [ ] iPhone 15 Pro Max (大屏)
- [ ] iPad Pro 12.9" (平板)
- [ ] 横竖屏切换流畅性
- [ ] 动态字体大小调整
- [ ] 分屏模式 (iPad)

### 横屏适配测试
- [ ] 所有内容都在屏幕内可见
- [ ] 组件大小合适，不会过小
- [ ] 布局美观，左右分布合理
- [ ] 无需滚动即可看到所有内容

### 动态类型测试
- [ ] 设置 → 显示与亮度 → 文字大小
- [ ] 测试最大辅助功能字体
- [ ] 确保内容不被截断

## ⚠️ 禁止事项

### 绝对禁止
- ❌ 创建自定义设备适配工具类 (如 `DeviceAdaptation`)
- ❌ 使用 `UIDevice.current` 检测设备类型
- ❌ 手动计算屏幕尺寸和比例
- ❌ 使用固定像素值 (如 `width: 350`)
- ❌ 复杂的 `GeometryReader` 嵌套
- ❌ 自定义文字高度缓存类
- ❌ 错误使用 `ViewThatFits(in: .vertical)` 进行横屏适配
- ❌ 横屏时仍使用ScrollView导致内容超出屏幕
- ❌ 横屏组件过小，浪费水平空间
- ❌ 竖屏内容适合时仍强制使用ScrollView

### 性能禁忌
- ❌ 过度使用 `GeometryReader`
- ❌ 在视图中进行复杂计算
- ❌ 忽略 `@Environment` 的性能优势
- ❌ 横屏时使用过大的组件尺寸

## 📚 Apple官方文档
- [Human Interface Guidelines - Layout](https://developer.apple.com/design/human-interface-guidelines/layout)
- [SwiftUI Size Classes](https://developer.apple.com/documentation/swiftui/environmentvalues/horizontalsizeclass)
- [Dynamic Type](https://developer.apple.com/documentation/uikit/uifont/scaling_fonts_automatically)
